/*
 * MTLGui.java
 *
 * Created on May 30, 2010, 10:27:59 AM
 */

package mtl;

import java.awt.Component;
import java.awt.DisplayMode;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Point;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ImageIcon;

/**
 * Generic launcher for MapTool.
 *
 * Prompts user for the various memory settings to use when starting
 * MapTool and then launches it with those settings preserving them
 * in the mt.cfg file for use later.
 *
 * @author Phergus
 */
@SuppressWarnings("serial")
public class MTLauncher extends javax.swing.JFrame {

    private static int maxMemVal = 256;
    private static int minMemVal = 64;
    private static int stackSizeVal = 1;
    private static boolean promptUser = true;

    private static String javaCommand = "java";
    private static String maxMemFormat = "-Xmx%dM";
    private static String maxMemStr;
    private static String minMemFormat = "-Xms%dM";
    private static String minMemStr;
    private static String stackSizeFormat = "-Xss%dM";
    private static String stackSizeStr;
    private static String jarCommand = "-jar";
    private static String mapToolJar = "maptool-*.jar";
    private static String mtArg = "run";

    private ImageIcon icon;

    /** Creates new form MTLGui */
    public MTLauncher() {
        icon = new javax.swing.ImageIcon(getClass().getResource("/mtl/MapToolLogo90x90.png"));
        boolean result = readCfgFile();
        if (promptUser) {
            initComponents();
            setLocation(getCenteredCorner(this));

            if (result) {
                jtfStackSize.setText(Integer.toString(stackSizeVal));
                jtfMaxMem.setText(Integer.toString(maxMemVal));
                jtfMinMem.setText(Integer.toString(minMemVal));
            }
            updateCommand();
        } else {
            updateStrings();
            writeCfgFile();
            launchMapTool();
            System.exit(0);
        }
    }

    /**
     * Launch MT in a separate process with its own JVM.
     *
     * Note that each string passed in must have just a single "argument".
     * Which is to say that you can't just lump them all into one string and
     * pass that.  So the max mem gets one, the min mem gets one and so on.
     * 
     */
    private void launchMapTool() {
        ProcessBuilder pb = new ProcessBuilder(javaCommand, maxMemStr,
                minMemStr, stackSizeStr, jarCommand, mapToolJar, mtArg);
        try {
            Process p = pb.start();
        } catch (IOException ex) {
            Logger.getLogger(MTLauncher.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jtfMaxMem = new javax.swing.JTextField();
        jtfMinMem = new javax.swing.JTextField();
        jtfStackSize = new javax.swing.JTextField();
        jlMaxMem = new javax.swing.JLabel();
        jlMinMem = new javax.swing.JLabel();
        jlStackSize = new javax.swing.JLabel();
        jlMTLogo = new javax.swing.JLabel();
        jbLaunch = new javax.swing.JButton();
        jtfCommand = new javax.swing.JTextField();
        jcbPromptUser = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("MapTool Launcher");
        setIconImage(icon.getImage());

        jtfMaxMem.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        jtfMaxMem.setText("256");
        jtfMaxMem.setToolTipText("Maximum memory (MB) for JVM.");
        jtfMaxMem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfMaxMemActionPerformed(evt);
            }
        });
        jtfMaxMem.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jtfMaxMemFocusLost(evt);
            }
        });

        jtfMinMem.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        jtfMinMem.setText("64");
        jtfMinMem.setToolTipText("Minimum memory (MB) for JVM.");
        jtfMinMem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfMinMemActionPerformed(evt);
            }
        });
        jtfMinMem.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jtfMinMemFocusLost(evt);
            }
        });

        jtfStackSize.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        jtfStackSize.setText("1");
        jtfStackSize.setToolTipText("Stack size (MB) for JVM.");
        jtfStackSize.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfStackSizeActionPerformed(evt);
            }
        });
        jtfStackSize.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jtfStackSizeFocusLost(evt);
            }
        });

        jlMaxMem.setLabelFor(jtfMaxMem);
        jlMaxMem.setText("Max Mem");

        jlMinMem.setLabelFor(jtfMinMem);
        jlMinMem.setText("Min Mem");

        jlStackSize.setLabelFor(jtfStackSize);
        jlStackSize.setText("Stack Size");

        jlMTLogo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mtl/MapToolLogo90x90.png"))); // NOI18N

        jbLaunch.setText("Launch MapTool");
        jbLaunch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbLaunchActionPerformed(evt);
            }
        });

        jtfCommand.setEditable(false);
        jtfCommand.setToolTipText("The Java command line that will be executed.");
        jtfCommand.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));

        jcbPromptUser.setSelected(true);
        jcbPromptUser.setText("Prompt");
        jcbPromptUser.setToolTipText("Uncheck to not show on next launch.");
        jcbPromptUser.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jcbPromptUserStateChanged(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(jcbPromptUser)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jbLaunch)
                            .addGap(1, 1, 1))
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(jlMTLogo)
                            .addGap(42, 42, 42)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(jlStackSize)
                                .addComponent(jlMinMem)
                                .addComponent(jlMaxMem))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(jtfMaxMem)
                                .addComponent(jtfMinMem, javax.swing.GroupLayout.DEFAULT_SIZE, 34, Short.MAX_VALUE)
                                .addComponent(jtfStackSize, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE))))
                    .addComponent(jtfCommand, javax.swing.GroupLayout.DEFAULT_SIZE, 237, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jlMaxMem)
                            .addComponent(jtfMaxMem, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jlMinMem)
                            .addComponent(jtfMinMem, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jlStackSize)
                            .addComponent(jtfStackSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addComponent(jlMTLogo))
                .addGap(18, 18, 18)
                .addComponent(jtfCommand, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jbLaunch)
                    .addComponent(jcbPromptUser))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void checkStackSize() {
        int ss = (int)(Double.parseDouble(jtfStackSize.getText()));
        if (ss < 1) {
            ss = 1;
            jtfStackSize.setText(Integer.toString(ss));
        }
        if (ss > (maxMemVal/64)) {
            ss = maxMemVal/64;
            jtfStackSize.setText(Integer.toString(ss));
        }
        stackSizeVal = ss;
    }

    private void checkMaxMem() {
        int max = (int)(Double.parseDouble(jtfMaxMem.getText()));
        if (max < minMemVal) {
            max = minMemVal;
        }
        if (max < 256) {
            max = 256;
        }
        jtfMaxMem.setText(Integer.toString(max));
        maxMemVal = max;
    }

    private void checkMinMem() {
        int min = (int)(Double.parseDouble(jtfMinMem.getText()));
        if (min > maxMemVal) {
            min = maxMemVal;
            jtfMinMem.setText(Integer.toString(min));
        }
        minMemVal = min;
    }

    private void updateStrings() {
        minMemStr = String.format(minMemFormat, minMemVal);
        maxMemStr = String.format(maxMemFormat, maxMemVal);
        stackSizeStr = String.format(stackSizeFormat, stackSizeVal);
    }

    private void updateCommand() {
        updateStrings();
        jtfCommand.setText(javaCommand + " " + minMemStr + " " + maxMemStr +
                " " + stackSizeStr + " " + jarCommand +
                " " + mapToolJar + " " + mtArg);
        jtfCommand.setCaretPosition(0);
    }

    File cfgFile = new File("mt.cfg");

    /**
     * Reads from a file named mt.cfg in the same directory to get
     * the following options.  Each option is placed on a single
     * line followed by an equal sign ('=') and then the
     * appropriate value.  The default values are shown.
     *
     * MAXMEM=256
     * MINMEM=64
     * STACKSIZE=2
     * JVM=java
     * PROMPT=true
     *
     * All memory sizes are in megabytes.
     */
    private boolean readCfgFile() {
        boolean rv = false;
        if (cfgFile.exists()) {
            BufferedReader br = null;
            try {
                br = new BufferedReader(new FileReader(cfgFile));
                String line;
                String [] arg;
                try {
                    line = br.readLine();
                    while(line != null ) {
                        arg = line.split("=");
                        if (arg.length == 2) {
                            if ("MAXMEM".equals(arg[0]))
                                maxMemVal = Integer.parseInt(arg[1]);
                            if ("MINMEM".equals(arg[0]))
                                minMemVal = Integer.parseInt(arg[1]);
                            if ("STACK".equals(arg[0]))
                                stackSizeVal = Integer.parseInt(arg[1]);
                            if ("JVM".equals(arg[0]))
                                javaCommand = arg[1];
                            if ("PROMPT".equals(arg[0]))
                                promptUser = "true".equals(arg[1].toLowerCase());

                            rv = true; // Assume that something was found.
                        }
                        line = br.readLine();
                    }
                } catch (IOException ex) {
                    Logger.getLogger(MTLauncher.class.getName()).log(Level.SEVERE, null, ex);
                }
            } catch (FileNotFoundException ex) {
                Logger.getLogger(MTLauncher.class.getName()).log(Level.SEVERE, null, ex);
            } finally {
                try {
                    br.close();
                } catch (IOException ex) {
                    Logger.getLogger(MTLauncher.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
        return rv;
    }

    private void writeCfgFile() {
        BufferedWriter br = null;
        try {
            br = new BufferedWriter(new FileWriter(cfgFile));
            br.write("MAXMEM="+maxMemVal);
            br.newLine();
            br.write("MINMEM="+minMemVal);
            br.newLine();
            br.write("STACK="+stackSizeVal);
            br.newLine();
            br.write("JVM="+javaCommand);
            br.newLine();
            br.write("PROMPT="+promptUser);
            br.newLine();
        } catch (IOException ex) {
            Logger.getLogger(MTLauncher.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                br.close();
            } catch (IOException ex) {
                Logger.getLogger(MTLauncher.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    /**
     * Get the point that will center the frame in the default display.
     *
     * @param c The component to be centered.
     * @return A point that will center the component.
     */
    private Point getCenteredCorner(Component c)
    {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice gd = ge.getDefaultScreenDevice();
        DisplayMode dm = gd.getDisplayMode();

        return new Point( (dm.getWidth() - c.getWidth()) / 2,
                        (dm.getHeight() - c.getHeight()) / 2 );
    }

    private void jbLaunchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbLaunchActionPerformed
        checkStackSize();
        checkMaxMem();
        checkMinMem();
        updateCommand();
        writeCfgFile();
        launchMapTool();
        System.exit(0);
    }//GEN-LAST:event_jbLaunchActionPerformed

    private void jtfStackSizeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfStackSizeActionPerformed
        checkStackSize();
        updateCommand();
    }//GEN-LAST:event_jtfStackSizeActionPerformed

    private void jtfStackSizeFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtfStackSizeFocusLost
        checkStackSize();
        updateCommand();
    }//GEN-LAST:event_jtfStackSizeFocusLost

    private void jtfMaxMemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfMaxMemActionPerformed
        checkMaxMem();
        updateCommand();
    }//GEN-LAST:event_jtfMaxMemActionPerformed

    private void jtfMaxMemFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtfMaxMemFocusLost
        checkMaxMem();
        updateCommand();
    }//GEN-LAST:event_jtfMaxMemFocusLost

    private void jtfMinMemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfMinMemActionPerformed
        checkMinMem();
        updateCommand();
    }//GEN-LAST:event_jtfMinMemActionPerformed

    private void jtfMinMemFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jtfMinMemFocusLost
        checkMinMem();
        updateCommand();
    }//GEN-LAST:event_jtfMinMemFocusLost

    private void jcbPromptUserStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jcbPromptUserStateChanged
        promptUser = jcbPromptUser.isSelected();
}//GEN-LAST:event_jcbPromptUserStateChanged

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MTLauncher().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jbLaunch;
    private javax.swing.JCheckBox jcbPromptUser;
    private javax.swing.JLabel jlMTLogo;
    private javax.swing.JLabel jlMaxMem;
    private javax.swing.JLabel jlMinMem;
    private javax.swing.JLabel jlStackSize;
    private javax.swing.JTextField jtfCommand;
    private javax.swing.JTextField jtfMaxMem;
    private javax.swing.JTextField jtfMinMem;
    private javax.swing.JTextField jtfStackSize;
    // End of variables declaration//GEN-END:variables

}
